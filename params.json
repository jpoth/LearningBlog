{"name":"Learningblog","tagline":"Design Pattern: Singleton Pattern","body":"Singleton pattern falls under Creational pattern \r\nSingleton: A class which only a single instance can exist.\r\n\r\nFollowing code snippet is from [MSDN](http://msdn.microsoft.com/en-us/library/ff650316.aspx)\r\n\r\nusing System;  \r\npublic class Singleton {   \r\nprivate static Singleton instance;    \r\nprivate Singleton() {}   \r\n  public static Singleton Instance  \r\n  {      \r\n       get        \r\n          {          \r\n           if (instance == null)      \r\n                {\r\n                  instance = new Singleton();         \r\n                }\r\n           return instance;      \r\n            }   \r\n          }\r\n  }  \r\nAdvantage of the following implementation: lazy initialization â€“ not initialized until asked for instance\r\nDisadvantage: not thread safe. If multiple threads enter the if block simultaneously then multiple instances might be created.\r\n\r\nIn case of implementing a singleton in multithread environment use locks \r\nDiscussion from [stackoverflow](\"http://stackoverflow.com/questions/728896/whats-the-use-of-the-syncroot-pattern\")\r\n \r\nReason for why use an private object to lock in a multithreaded environment\r\n\r\nIf you have an internal data structure that you want to prevent simultaneous access to by multiple threads, you should always make sure the object you're locking on is not public.The reasoning behind this is that a public object can be locked by anyone, and thus you can create deadlocks because you're not in total control of the locking pattern.This means that locking on this is not an option, since anyone can lock on that object. Likewise, you should not lock on something you expose to the outside world.Which means that the best solution is to use an internal object, and thus the tip is to just use Object.\r\nLocking data structures is something you really need to have full control over, otherwise you risk setting up a scenario for deadlocking, which can be very problematic to handle.\r\nMarking the class as sealed makes sure that no one can inherit from the class. If someone inherits from the class then it may end up instantiating the class. This would happen if a derived class is instantiated, which would in turn call the base class constructor (even if it is private).[1](http://stackoverflow.com/a/728913/147306)\r\n \r\nFollowing code snippet is from [MSDN](http://msdn.microsoft.com/en-us/library/ff650316.aspx)\r\nusing System;  \r\npublic sealed class Singleton {  \r\n\t  private static volatile Singleton instance;   \r\n\t private static object syncRoot = new Object();   \r\n\t  private Singleton() {}     \r\n\tpublic static Singleton Instance    {      \r\n\t get        \r\n\t{         \r\n\t\t if (instance == null)           \r\n\t\t{            \r\n\t\t\t lock (syncRoot)            \r\n\t\t\t  {                \r\n\t\t\t\tif (instance == null)                  \r\n\t  \t\t\tinstance = new Singleton();           \r\n \t }         \r\n                        }          \r\n \treturn instance;      \r\n \t}\t  \r\n      } \r\n}  \r\n\r\nA singleton allows access to a single created instance - that instance (or rather, a reference to that instance) can be passed as a parameter to other methods, and treated as a normal object.\r\n\r\nA static class allows only static methods.[Jon Skeet on static vs singleton class](http://stackoverflow.com/a/519536/147306)\r\n\r\nReferences:\r\n\r\n1.  [Why singleton class should be sealed](http://stackoverflow.com/questions/11668390/why-singleton-class-should-be-sealed)\r\n\r\n2.  [MSDN](http://msdn.microsoft.com/en-us/library/ff650316.aspx)","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}